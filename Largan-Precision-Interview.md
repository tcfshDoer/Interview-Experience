面試官給出了一個情境：「假設你現在要開發一套系統，負責收集產線上數百台機台的即時壓力數據，並將其處理後傳輸到雲端資料庫。你會如何設計？」
第一幕：選擇數據結構 (List vs. Array)
面試官： 「每秒有上萬筆浮點數數據進來，你會用 Python 的 list 還是 array 來存？為什麼？」
我的回答：
「我會選擇 Array (特別是 NumPy Array)。在大數據場景下，list 就像是散裝的包裹，資料在記憶體中到處亂放，處理起來很慢；而 array 是整齊排列的集裝箱，記憶體連續存放，能進行『向量化運算』。如果用 list 算平均值要 1 秒，用 array 可能只要 0.01 秒。對於大立光這種追求精密與速度的產線，效能就是金錢。」
第二幕：API 的併發處理 (def vs. async def)
面試官： 「數據收好了，現在要寫一個 API 把數據傳出去。你會用 def 還是 async def 定義這個傳輸函式？」
我的回答：
「我會用 async def。
如果用普通的 def，當 API 在等待雲端伺服器回應時（I/O 阻塞），整個監控程式會『斷線』停在那裡等，這在即時產線上是致命的。
使用 async def 配合 await，程式在等待網路回傳的空檔，可以繼續去抓下一秒的機台數據。這就是非同步處理，能確保系統在高併發環境下依然流暢運作。」
第三幕：物件引用的陷阱 (The Append Trap)
面試官： 「好，最後考你邏輯。如果你用 list2.append(list1)，接著又用 list3.append(list2)，最後你修改了 list1[0] = "Error"。當我依序輸出這三個 list 時，會發生什麼變化？」
我的回答：
「這是一個經典的 Reference (引用) 陷阱。
輸出 list1 會看到 "Error"。
輸出 list2，你會發現它包含的 list1 也變成了 "Error"。
輸出 list3，連最外層的數據也會跟著變。
結論： 因為 append 進去的是記憶體地址而非數值副本。在處理產線邏輯時，如果不小心使用引用而非 copy()，可能會導致原本正常的歷史數據被後來的錯誤數據污染，造成誤報警。」
